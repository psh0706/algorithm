acc = 0
color = [0 for _ in range(200001)]
size = [0 for _ in range(2001)]
info = []
N = int(input())
for i in range(N):
    c, s = map(int, input().split())
    info.append([i, c, s])

result = [0 for _ in range(N)]
info.sort(key=lambda x: (x[2]))

for j in range(N):
    idx, c, s = info[j][0], info[j][1], info[j][2]
    result[idx] = acc - size[s] - color[c]

    k = j - 1
    while k >= 0 and info[k][2] == s:
        if c == info[k][1]:
            result[idx] += s
        k -= 1

    color[c] += s
    size[s] += s
    acc += s

for r in result:
    print(r)

"""
시간 복잡도를 매우 잘 활용해야 하는 문제로
타임 리밋이 1초이기 때문에 단순 순회하게 되면 최대 200000인 N값을  N**2 번 돌려 시간초과 폭탄을 맞게된다.
기본 흐름은 다음과 같다.

1. 사이즈를 기준으로 정렬한다
2. 사이즈가 가장 작은것부터 쭉 더해가는데 (사이즈의 누적합)
3. 같은색, 같은 크기인 공들의 사이즈 들을 빼준다.
4. 같은색이면서 같은 크기인 공들의 사이즈는 두 번 빠진 것이므로
   기준 공으로 부터 거꾸로 순회하며 같은크기, 같은 공인 공들의 사이즈를 한번 더해준다.

계산을 편하게 하기 위해서는
색별, 사이즈별 사이즈의 합을 별도의 배열로 (이것 역시 누적) 구해두면 된다.

예) 공 3개의 입력이 주어졌다 (색상, 크기 순)
(1) 1 2
(2) 1 4
(3) 3 2

1. 정렬한다 (사이즈 기준)
(1) 1 2
(3) 3 2
(2) 1 4

2. 사이즈가 작은 것 부터 누적합을 더한다. (누적합 - 같은색 - 같은크기 + 두번빠진 것 더하기)
acc = 0
color = [0, 0, 0, 0, 0]
size = [0, 0, 0, 0, 0]
기준 : (1) 1 2
결과 : 0 - color[1] - size[2] + (두번 빠진 것)
      = 0 - 0 - 0 + 0
      = 0
* acc, color, size 업데이트
--------------------------
acc = 2
color = [2, 0, 0, 0, 0]
size = [0, 2, 0, 0, 0]
기준 : (3) 3 2
결과 : 2 - color[3] - size[2] + (두번 빠진 것)
     = 2 - 0 - 2 + 0
     = 0
* acc, color, size 업데이트
--------------------------
acc = 4
color = [2, 0, 2, 0, 0]
size = [0, 4, 0, 0, 0]
기준 : (2) 1 4
결과 : 4 - color[1] - size[4] + (두번 빠진 것)
     = 4 - 2 - 0 + 0
     = 2
* acc, color, size 업데이트

(1)번이 먹을수 있는 크기 = 0
(2)번이 먹을 수 있는 크기 = 2
(3)번이 먹을 수 있는 크기 = 0

"""

