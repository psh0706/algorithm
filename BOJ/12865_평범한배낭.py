N, K = map(int, input().split())
info = []
for _ in range(N):
    w, v = map(int, input().split())
    info.append([w, v])

dp = [0 for _ in range(K+1)]
for i in range(N):
    for j in range(K, -1, -1):
        if info[i][0] <= j:
            dp[j] = max(dp[j], dp[j - info[i][0]]+info[i][1])

print(max(dp))

"""
대표적인 dp 문제인 knapsack problem

한 item 에 대해 넣을 경우와 넣지 않을 경우 중 가치가 더 큰것을 선택하며
최적화 해 나간다.

item 을 하나 하나 추가하며 버틸수 있는 무게인 K가 0 ~ K 일 때 까지 순회하며 최적화 하는데
item 이 들어갈 수 있는 무게인지 확인하고 (line 10)
아이템을 넣지 않은 경우와 (dp[j])
아이템을 넣은 경우 *(dp[j - info[i][0]] + info[i][1]) 를 확인한다.

info[i][0]은 아이템 i의 무게 , info[i][1]은 아이템 i의 가치이다.
dp[j-info[i][0]] 은 가방에 item 을 넣기위해 그만큼의 무게를 뺀 경우의 최적값(=가치의 최적값)에, 
item 을 넣었을 때의 가치를 합한 값이다 

example)

1. item 1 넣기
    item 1 -> w[1] = 2, v[1] = 5 이고 K는 최대 3이라고 하자.
    최대 용량이 3인 가방에 1번 아이템을 넣는데, 무게가 2이고 가치가 5인 아이템을 넣는다는 뜻이다.
    아이템을 넣었을때 dp[3 - w[2]] + v[2], 넣지 않았을때 dp[3].
    넣었을 때의 식은 dp[2]+v[1] 과 같고, dp[2]는 최대용량이 2인 가방에 최대의 가치로 물건을 넣었을 때의 가치값의 총 합이다.
    기존 dp[3]의 값이 0 이고 dp[2]의 값 역시 0 이라고 하자 (아무것도 들어가지 않은 상태)
    dp[3] = 0,
    dp[3 - w[1]]+v[1] = 5 이므로
    dp[3]은 5로 갱신된다.
    
    이와 같은 방식으로 가방의 용량이 2일때, 1일때를 수행하여 주면 된다.
    결과는 아래와 같다. (용량이 1일 경우, 무게가 2인 item1 은 들어갈 수 없다, k=0은 계산을 위한 초기화 값.)
    k:  0  1  2  3 
    ---------------
    v:  0  0  5  5
   
2. item 2 넣기
    item 2 -> w[2] = 1, v[2] = 3 일때
    dp[3] = max( dp[3], dp[3 - w[2]] + v[2]) = max(5, dp[2]+3) = max(5, 8) = 8
    dp[2] = max( dp[2], dp[2 - w[2]] + v[2]) = max(5, dp[1]+3) = max(5, 3) = 5
    dp[1] = max( dp[1], dp[1 - w[2]] + v[2]) = max(0, dp[0]+3) = max(0, 3) = 3
    k:  0  1  2  3 
    ---------------
    v:  0  3  5  8

+) 내림차순으로 최적화를 진행하는 이유?
    그런데 왜 내림차순으로 최적화 값을 갱신할까?
    방금 전 item 2 를 넣었던 경우를 생각해보자.
    오름차순으로 갱신할 경우
    dp[1] = max( dp[1], dp[1 - w[2]] + v[2]) = max(0, dp[0]+3) = max(0, 3) = 3
    dp[2] = max( dp[2], dp[2 - w[2]] + v[2]) = max(5, dp[1]+3) = max(5, 6) = 6
    dp[3] = max( dp[3], dp[3 - 던[2]] + v[2]) = max(5, dp[2]+3) = max(5, 9) = 9
    k:  0  1  2  3 
    ---------------
    v:  0  3  6  9
    
    v[2] 를 누적해서 합해버리며 제대로 된 결과를 내지 못하기 때문이다.

사실 이 문제를 먼저 풀고 7579번 문제를 풀었어야 했으나 ㅠ 어제 7579번을 먼저 풀면서 냅색을 아주 호되게 배워버려서
배낭채우기 문제는 이제 평생 안까먹을것 같다 ㅋㅋㅋㅋ..

"""