import sys
INF = sys.maxsize
N = int(input())
arr = [0 for _ in range(N + 1)]

for i in range(2, N + 1):
    a, b, c = INF, INF, INF

    if i % 3 == 0:
        a = arr[i // 3]

    if i % 2 == 0:
        b = arr[i // 2]

    c = arr[i - 1]

    arr[i] = min(a, b, c) + 1

print(arr[-1])

"""
DP 문제!

상향식으로 풀었당
1에서 N까지 최적화시키며 계산해 나간다.
연산은 3가지가 있다.

1. 3으로 나누어 떨어질 때 3으로 나누기
2. 2로 나누어 떨어질 때 2로 나누기
3. -1 하기

예를 들어서 수 2는  2, 3번 연산을 수행할 수 있고 각각의 연산 결과는 1, 1이다.
1번의 최적화 값은 0으로 초기화 되어 있으므로 각각의 최적화 값은 0, 0이고
그 중 작은 값은 (같지만) 0 이다.
한 번 연산한 것을 더해 2의 최적화 값은 1이다.

같은 방식으로 수 3은 1, 3번 연산을 수행할수 있고 각각의 연산 결과가 1, 2이다.
각각의 최적화 값은 0, 1 이며 그 중 작은 값은 0 이다.
한 번 연산한 것을 더해 3의 최적화 값은 1이다.

같은 방법을 진행하면 4의 최적화값은 2의 최적화 값에 1을 더한 2이다.
이것을 2번 인덱스 부터 N번 인덱스까지 진행한다.
"""