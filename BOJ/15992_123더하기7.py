n = int(input())
cases = [list(map(int, input().split())) for _ in range(n)]
dp = [[0 for _ in range(1001)] for _ in range(1001)]
dp[1][1] = 1
dp[2][1] = 1
dp[2][2] = 1
dp[3][1] = 1
dp[3][2] = 2
dp[3][3] = 1

for i in range(4, 1001):
    for j in range(2, 1001):
        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 2][j - 1] + dp[i - 3][j - 1]) % 1000000009

for case in cases:
    print(dp[case[0]][case[1]])

"""
dp[숫자][숫자를 나타내는 조합의 길이] = 조합의 개수
1, 2, 3을 가지고 나타내야하기 때문에 숫자 n의 1전, 2전, 3전 숫자들의 dp 테이블을 참고한다.
예를들어 길이가 3인 조합을 찾고싶을때는, "길이가 2인" 1전, 2전, 3전 숫자들에 1, 2, 3을 각각 하나씩 붙히면 가능하다.
아래와 같은 테이블이 있다고 할 때, 숫자 4의 조합들을 찾아보도록 하자.

1: 1               - 1*1개
2: 11, 2           - 1*1개, 2*1개
3: 111, 12, 21, 3  - 1*1개, 2*2개, 3*1개
------------------------
i\j  0  1  2  3  4  5 ...
------------------------
 0 |0  0  0  0  0  0 ...
 1 |0  1  0  0  0  0 ...
 2 |0  1  1  0  0  0 ...
 3 |0  1  2  1  0  0 ...

ex) 4를 길이 1의 조합으로 나타내는 방법 
= (3을 길이 0의 조합으로 나타낸 것에 +1 한 것) + (2를 길이 0의 조합으로 나타낸 것에 +2 한 것) + (1을 길이 0의 조합으로 나타낸 것에 +3 한 것)
= 0개(x) + 0개(x) + 0개(x)
= 0개

ex) 4를 길이 2의 조합으로 나타내는 방법 
= (3을 길이 1의 조합으로 나타낸 것에 +1 한 것) + (2를 길이 1의 조합으로 나타낸 것에 +2 한 것) + (1을 길이 1의 조합으로 나타낸 것에 +3 한 것)
= 1개(31) + 1개(22) + 1개(13)
= 3개

ex) 4를 길이 3의 조합으로 나타내는 방법 
= (3을 길이 2의 조합으로 나타낸 것에 +1 한 것) + (2를 길이 2의 조합으로 나타낸 것에 +2 한 것) + (1을 길이 2의 조합으로 나타낸 것에 +3 한 것)
= 2개(211, 121) + 1개(112) + 0개(x)
= 3개

ex) 4를 길이 4의 조합으로 나타내는 방법 
= (3을 길이 3의 조합으로 나타낸 것에 +1 한 것) + (2를 길이 3의 조합으로 나타낸 것에 +2 한 것) + (1을 길이 3의 조합으로 나타낸 것에 +3 한 것)
= 1개(1111) + 0개(x) + 0개(x)
= 1개

(반복)

i\j 0  1  2  3  4  5 ...
------------------------
 0 |0  0  0  0  0  0 ...
 1 |0  1  0  0  0  0 ...
 2 |0  1  1  0  0  0 ...
 3 |0  1  2  1  0  0 ...
 4 |0  0  3  3  1  0 ...
 
위 식을 일반화 하면 다음과 같다.
dp[i][j] = dp[i-1][j-1] + dp[i-2][j-1] + dp[i-3][j-1]

"""
